#include "imports/stdlib.fc";

;; Escrow Contract - контракт безопасной сделки с арбитражем
;;
;; Storage:
;;   buyer: MsgAddress - покупатель (инициатор сделки)
;;   seller: MsgAddress - продавец
;;   arbiter: MsgAddress - арбитр для разрешения споров
;;   deal_amount: Coins - сумма сделки (неприкосновенная)
;;   storage_reserve: Coins - резерв на rent и газ (отдельный от сделки)
;;   status: uint8 - 0=active, 1=completed, 2=disputed, 3=refunded
;;   created_at: uint32 - timestamp создания
;;   timeout: uint32 - timeout в секундах

;; Операции (op codes)
const int op::release_funds = 1;      ;; Покупатель подтверждает получение → оплата продавцу
const int op::confirm_delivery = 2;   ;; Продавец подтверждает отправку
const int op::open_dispute = 3;       ;; Открыть спор → вызов арбитра
const int op::resolve_dispute = 4;    ;; Арбитр решает спор (winner: 0=buyer, 1=seller)
const int op::refund = 5;             ;; Возврат средств покупателю (при таймауте)

;; Статусы
const int status::active = 0;
const int status::completed = 1;
const int status::disputed = 2;
const int status::refunded = 3;

;; Errors
const int error::invalid_op = 100;
const int error::unauthorized = 101;
const int error::wrong_status = 102;
const int error::insufficient_funds = 103;
const int error::timeout_not_reached = 104;

;; Константы
const int min_storage_reserve = 5000000;   ;; 0.005 TON минимальный остаток для операций
const int completion_gas = 10000000;       ;; 0.01 TON на газ завершения

;; =============== Messages ===============

() recv_internal(cell in_msg_full, slice in_msg_body) impure {
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    
    ;; Игнорируем bounced сообщения
    if (flags & 1) {
        return ();
    }

    slice sender_address = cs~load_msg_addr();
    
    ;; Пустое init сообщение при деплое - принимаем (данные уже в storage из StateInit)
    if (in_msg_body.slice_empty?()) {
        return ();  ;; Успешный деплой
    }

    int op = in_msg_body~load_uint(32);
    
    ;; Валидация op code (1-5: release, confirm, dispute, resolve, refund)
    throw_unless(error::invalid_op, (op >= 1) & (op <= 5));

    ;; Загружаем текущее состояние (данные были установлены при деплое через StateInit)
    (slice buyer, slice seller, slice arbiter, int deal_amount, int storage_reserve, int status, int created_at, int timeout) = load_data();

    ;; === Покупатель подтверждает получение → оплата продавцу ===
    if (op == op::release_funds) {
        throw_unless(error::unauthorized, equal_slices(sender_address, buyer));
        throw_unless(error::wrong_status, status == status::active);
        
        ;; Отправляем deal_amount продавцу (платим газ отдельно)
        send_ton(seller, deal_amount, 1);
        
        ;; Возвращаем остаток storage_reserve покупателю + self-destruct
        ;; mode 128 = отправить весь оставшийся баланс + destroy contract
        send_ton(buyer, 0, 128);
        
        return ();  ;; Контракт уничтожен
    }

    ;; === Продавец подтверждает отправку ===
    if (op == op::confirm_delivery) {
        throw_unless(error::unauthorized, equal_slices(sender_address, seller));
        throw_unless(error::wrong_status, status == status::active);
        
        ;; Просто записываем подтверждение (можно расширить логику)
        ;; В реальной версии можно добавить флаг delivery_confirmed
        return ();
    }

    ;; === Открыть спор ===
    if (op == op::open_dispute) {
        ;; Спор может открыть покупатель или продавец
        throw_unless(error::unauthorized, 
            equal_slices(sender_address, buyer) | equal_slices(sender_address, seller)
        );
        throw_unless(error::wrong_status, status == status::active);
        
        ;; Меняем статус на disputed
        save_data(buyer, seller, arbiter, deal_amount, storage_reserve, status::disputed, created_at, timeout);
        return ();
    }

    ;; === Арбитр решает спор ===
    if (op == op::resolve_dispute) {
        throw_unless(error::unauthorized, equal_slices(sender_address, arbiter));
        throw_unless(error::wrong_status, status == status::disputed);
        
        ;; Читаем решение: 0 = buyer wins, 1 = seller wins
        int winner = in_msg_body~load_uint(8);
        
        if (winner == 0) {
            ;; Buyer победил: получает deal_amount
            send_ton(buyer, deal_amount, 1);
            ;; Seller получает остаток storage + self-destruct
            send_ton(seller, 0, 128);
        } else {
            ;; Seller победил: получает deal_amount
            send_ton(seller, deal_amount, 1);
            ;; Buyer получает остаток storage + self-destruct
            send_ton(buyer, 0, 128);
        }
        
        return ();  ;; Контракт уничтожен
    }

    ;; === Возврат по таймауту ===
    if (op == op::refund) {
        throw_unless(error::unauthorized, equal_slices(sender_address, buyer));
        throw_unless(error::wrong_status, status == status::active);
        
        ;; Проверяем что прошел таймаут
        throw_unless(error::timeout_not_reached, now() > (created_at + timeout));
        
        ;; Возвращаем deal_amount buyer'у
        send_ton(buyer, deal_amount, 1);
        
        ;; Остаток storage_reserve тоже buyer'у + self-destruct
        send_ton(buyer, 0, 128);
        
        return ();  ;; Контракт уничтожен
    }

    ;; Неизвестная операция
    throw(error::invalid_op);
}

;; =============== Storage ===============

;; Загрузка данных из хранилища
(slice, slice, slice, int, int, int, int, int) load_data() inline {
    slice ds = get_data().begin_parse();
    
    return (
        ds~load_msg_addr(),      ;; buyer
        ds~load_msg_addr(),      ;; seller
        ds~load_msg_addr(),      ;; arbiter
        ds~load_coins(),         ;; deal_amount
        ds~load_coins(),         ;; storage_reserve
        ds~load_uint(8),         ;; status
        ds~load_uint(32),        ;; created_at
        ds~load_uint(32)         ;; timeout
    );
}

;; Сохранение данных в хранилище
() save_data(slice buyer, slice seller, slice arbiter, int deal_amount, int storage_reserve, int status, int created_at, int timeout) impure inline {
    set_data(
        begin_cell()
            .store_slice(buyer)
            .store_slice(seller)
            .store_slice(arbiter)
            .store_coins(deal_amount)
            .store_coins(storage_reserve)
            .store_uint(status, 8)
            .store_uint(created_at, 32)
            .store_uint(timeout, 32)
            .end_cell()
    );
}

;; =============== Helpers ===============

;; Проверка что sender == address
int equal_slices(slice a, slice b) inline {
    return equal_slice_bits(a, b);
}

;; Отправка сообщения с TON
() send_ton(slice to, int amount, int mode) impure inline {
    cell msg = begin_cell()
        .store_uint(0x18, 6)           ;; flags
        .store_slice(to)               ;; destination
        .store_coins(amount)           ;; amount
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)  ;; default message headers
        .end_cell();
    
    send_raw_message(msg, mode);
}

;; =============== Get Methods ===============

;; Получить адрес покупателя
slice get_buyer() method_id {
    (slice buyer, _, _, _, _, _, _, _) = load_data();
    return buyer;
}

;; Получить адрес продавца
slice get_seller() method_id {
    (_, slice seller, _, _, _, _, _, _) = load_data();
    return seller;
}

;; Получить адрес арбитра
slice get_arbiter() method_id {
    (_, _, slice arbiter, _, _, _, _, _) = load_data();
    return arbiter;
}

;; Получить сумму сделки (чистая, неприкосновенная)
int get_deal_amount() method_id {
    (_, _, _, int deal_amount, _, _, _, _) = load_data();
    return deal_amount;
}

;; Получить резерв на storage
int get_storage_reserve() method_id {
    (_, _, _, _, int storage_reserve, _, _, _) = load_data();
    return storage_reserve;
}

;; Получить статус сделки
int get_status() method_id {
    (_, _, _, _, _, int status, _, _) = load_data();
    return status;
}

;; Получить всю информацию о сделке
(slice, slice, slice, int, int, int, int, int) get_deal_info() method_id {
    return load_data();
}

;; Получить время создания
int get_created_at() method_id {
    (_, _, _, _, _, _, int created_at, _) = load_data();
    return created_at;
}

;; Получить timeout
int get_timeout() method_id {
    (_, _, _, _, _, _, _, int timeout) = load_data();
    return timeout;
}

;; Проверка истек ли timeout
int is_expired() method_id {
    (_, _, _, _, _, _, int created_at, int timeout) = load_data();
    return now() > (created_at + timeout);
}
