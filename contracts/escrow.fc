#include "imports/stdlib.fc";
#include "constants.fc";

;; Escrow Contract - контракт безопасной сделки
;;
;; Storage:
;;   buyer: MsgAddress - покупатель (инициатор сделки)
;;   seller: MsgAddress - продавец
;;   deal_amount: Coins - сумма сделки (неприкосновенная)
;;   status: uint8 - 0=active, 1=completed, 2=disputed, 3=refunded
;;   created_at: uint32 - timestamp создания
;;   timeout: uint32 - timeout в секундах
;;
;; Note: storage_reserve не хранится отдельно - он часть баланса контракта.
;; При завершении mode::send_all_destroy возвращает весь остаток автоматически.

;; Операции (op codes)
const int op::release_funds = 1;      ;; Покупатель подтверждает получение → оплата продавцу
const int op::confirm_delivery = 2;   ;; Продавец подтверждает отправку
const int op::refund = 3;             ;; Возврат средств покупателю (при таймауте)

;; =============== Messages ===============

() recv_internal(cell in_msg_full, slice in_msg_body) impure {
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    
    ;; Игнорируем bounced сообщения
    if (flags & 1) {
        return ();
    }

    slice sender_address = cs~load_msg_addr();
    
    ;; Init сообщение при деплое - принимаем пустое body (данные уже в storage из StateInit)
    if (in_msg_body.slice_empty?()) {
        return ();  ;; Успешный деплой
    }

    int op = in_msg_body~load_uint(32);
    
    ;; Валидация op code (1-3: release, confirm, refund)
    throw_unless(error::invalid_op, (op >= 1) & (op <= 3));

    ;; Загружаем текущее состояние (данные были установлены при деплое через StateInit)
    (slice buyer, slice seller, int deal_amount, int status, int created_at, int timeout) = load_data();

    ;; === Покупатель подтверждает получение → оплата продавцу ===
    if (op == op::release_funds) {
        throw_unless(error::unauthorized, equal_slices(sender_address, buyer));
        throw_unless(error::wrong_status, status == status::active);
        
        ;; Storage reserve рассчитан точно при деплое → гарантированно хватит на весь timeout
        ;; Отправляем полный deal_amount продавцу
        send_ton(seller, deal_amount, mode::pay_fees_separately);
        
        ;; Возвращаем весь остаток (storage_reserve - rent - gas) buyer'у + destroy
        send_ton(buyer, 0, mode::send_all_destroy);
        
        return ();  ;; Контракт уничтожен
    }

    ;; === Продавец подтверждает отправку ===
    if (op == op::confirm_delivery) {
        throw_unless(error::unauthorized, equal_slices(sender_address, seller));
        throw_unless(error::wrong_status, status == status::active);
        
        ;; Просто записываем подтверждение (можно расширить логику)
        ;; В реальной версии можно добавить флаг delivery_confirmed
        return ();
    }

    ;; === Возврат по таймауту ===
    if (op == op::refund) {
        throw_unless(error::unauthorized, equal_slices(sender_address, buyer));
        throw_unless(error::wrong_status, status == status::active);
        
        ;; Проверяем что прошел таймаут
        throw_unless(error::timeout_not_reached, now() > (created_at + timeout));
        
        ;; Возвращаем всё buyer'у: deal_amount + storage + destroy
        send_ton(buyer, 0, mode::send_all_destroy);
        
        return ();  ;; Контракт уничтожен
    }

    ;; Неизвестная операция
    throw(error::invalid_op);
}

;; =============== Storage ===============

;; Загрузка данных из хранилища
(slice, slice, int, int, int, int) load_data() inline {
    slice ds = get_data().begin_parse();
    
    return (
        ds~load_msg_addr(),      ;; buyer
        ds~load_msg_addr(),      ;; seller
        ds~load_coins(),         ;; deal_amount
        ds~load_uint(8),         ;; status
        ds~load_uint(32),        ;; created_at
        ds~load_uint(32)         ;; timeout
    );
}

;; Сохранение данных в хранилище
() save_data(slice buyer, slice seller, int deal_amount, int status, int created_at, int timeout) impure inline {
    set_data(
        begin_cell()
            .store_slice(buyer)
            .store_slice(seller)
            .store_coins(deal_amount)
            .store_uint(status, 8)
            .store_uint(created_at, 32)
            .store_uint(timeout, 32)
            .end_cell()
    );
}

;; =============== Helpers ===============

;; Проверка что sender == address
int equal_slices(slice a, slice b) inline {
    return equal_slice_bits(a, b);
}

;; Отправка сообщения с TON
() send_ton(slice to, int amount, int mode) impure inline {
    cell msg = begin_cell()
        .store_uint(msg_flag::non_bounceable, 6)          ;; flags
        .store_slice(to)               ;; destination
        .store_coins(amount)           ;; amount
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)  ;; default message headers
        .end_cell();
    
    send_raw_message(msg, mode);
}

;; =============== Get Methods ===============

;; Получить адрес покупателя
slice get_buyer() method_id {
    (slice buyer, _, _, _, _, _) = load_data();
    return buyer;
}

;; Получить адрес продавца
slice get_seller() method_id {
    (_, slice seller, _, _, _, _) = load_data();
    return seller;
}

;; Получить сумму сделки (чистая, неприкосновенная)
int get_deal_amount() method_id {
    (_, _, int deal_amount, _, _, _) = load_data();
    return deal_amount;
}

;; Получить статус сделки
int get_status() method_id {
    (_, _, _, int status, _, _) = load_data();
    return status;
}

;; Получить всю информацию о сделке
(slice, slice, int, int, int, int) get_deal_info() method_id {
    return load_data();
}

;; Получить время создания
int get_created_at() method_id {
    (_, _, _, _, int created_at, _) = load_data();
    return created_at;
}

;; Получить timeout
int get_timeout() method_id {
    (_, _, _, _, _, int timeout) = load_data();
    return timeout;
}

;; Проверка истек ли timeout
int is_expired() method_id {
    (_, _, _, _, int created_at, int timeout) = load_data();
    return now() > (created_at + timeout);
}
