#include "imports/stdlib.fc";
#include "constants.fc";

;; Factory Contract - фабрика для создания Escrow контрактов
;;
;; Storage:
;;   owner: MsgAddress - владелец фабрики
;;   escrow_code: Cell - код Escrow контракта для деплоя
;;   total_deployed: uint64 - всего задеплоено контрактов

;; Операции (op codes)
const int op::create_escrow = 1;      ;; Создать новый Escrow контракт
const int op::update_code = 2;        ;; Обновить код Escrow (owner only)
const int op::change_owner = 3;       ;; Сменить владельца

;; Константы стоимостей
const int min_escrow_amount = 100000000;  ;; 0.1 TON минимальная сумма для эскроу
const int deploy_gas = 100000000;         ;; 0.1 TON на деплой (mode::pay_fees_separately - берется с баланса Factory)
const int storage_reserve = 5000000;      ;; 0.005 TON резерв (достаточно для 48ч + операции)

;; =============== Messages ===============

() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    
    ;; Игнорируем bounced сообщения
    ;; При bounce деньги автоматически зачисляются на баланс Factory
    ;; Owner может вывести их вручную при необходимости
    if (flags & flag::bounced) {
        return ();
    }

    slice sender_address = cs~load_msg_addr();
    
    ;; Пустое сообщение → bounce
    throw_if(error::invalid_op, in_msg_body.slice_empty?());
    
    int op = in_msg_body~load_uint(32);
    
    if (op == op::create_escrow) {
        handle_create_escrow(msg_value, sender_address, in_msg_body);
        return ();
    }

    if (op == op::update_code) {
        handle_update_code(sender_address, in_msg_body);
        return ();
    }

    if (op == op::change_owner) {
        handle_change_owner(sender_address, in_msg_body);
        return ();
    }
    
    ;; Неизвестная операция → bounce
    throw(error::invalid_op);
}

;; =============== Operation Handlers ===============

;; Обработка создания Escrow
() handle_create_escrow(int msg_value, slice buyer, slice in_msg_body) impure inline {
    ;; Читаем параметры сделки
    slice seller = in_msg_body~load_msg_addr();
    int deal_amount = in_msg_body~load_coins();
    int timeout = in_msg_body~load_uint(32);
    
    ;; Валидация
    throw_unless(error::insufficient_funds, msg_value >= (deal_amount + storage_reserve + deploy_gas));
    throw_unless(error::invalid_op, deal_amount >= min_escrow_amount);
    throw_unless(error::invalid_op, timeout > timeout::min);
    throw_unless(error::invalid_op, timeout < timeout::max);
    
    ;; Загружаем данные
    (slice owner, cell escrow_code, int total_deployed) = load_data();
    
    ;; Создаем StateInit
    cell escrow_data = build_escrow_data(buyer, seller, deal_amount, timeout);
    cell state_init = build_state_init(escrow_code, escrow_data);
    slice escrow_addr = calculate_address_by_state_init(state_init);
    
    ;; Деплой
    send_deploy_message(escrow_addr, state_init, deal_amount + storage_reserve);
    
    ;; Возврат сдачи
    send_ton(buyer, 0, mode::carry_remaining_value);
    
    ;; Обновляем счетчик
    save_data(owner, escrow_code, total_deployed + 1);
}

;; Обработка обновления кода
() handle_update_code(slice sender, slice in_msg_body) impure inline {
    (slice owner, _, int total_deployed) = load_data();
    throw_unless(error::unauthorized, equal_slices(sender, owner));
    
    cell new_code = in_msg_body~load_ref();
    save_data(owner, new_code, total_deployed);
}

;; Обработка смены владельца
() handle_change_owner(slice sender, slice in_msg_body) impure inline {
    (slice owner, cell escrow_code, int total_deployed) = load_data();
    throw_unless(error::unauthorized, equal_slices(sender, owner));
    
    slice new_owner = in_msg_body~load_msg_addr();
    save_data(new_owner, escrow_code, total_deployed);
}

;; =============== Storage ===============

(slice, cell, int) load_data() inline {
    slice ds = get_data().begin_parse();
    
    return (
        ds~load_msg_addr(),    ;; owner
        ds~load_ref(),         ;; escrow_code
        ds~load_uint(64)       ;; total_deployed
    );
}

() save_data(slice owner, cell escrow_code, int total_deployed) impure inline {
    set_data(
        begin_cell()
            .store_slice(owner)
            .store_ref(escrow_code)
            .store_uint(total_deployed, 64)
            .end_cell()
    );
}

;; =============== Helpers ===============

int equal_slices(slice a, slice b) inline {
    return equal_slice_bits(a, b);
}

;; Построение Escrow data для StateInit
cell build_escrow_data(slice buyer, slice seller, int deal_amount, int timeout) inline {
    return begin_cell()
        .store_slice(buyer)
        .store_slice(seller)
        .store_coins(deal_amount)
        .store_uint(status::active, 8)
        .store_uint(now(), 32)         ;; created_at
        .store_uint(timeout, 32)
        .end_cell();
}

;; Построение StateInit
cell build_state_init(cell code, cell data) inline {
    return begin_cell()
        .store_uint(0, 2)           ;; split_depth:(Maybe (## 5)) = nothing (0)
                                    ;; special:(Maybe TickTock) = nothing (0)
        .store_maybe_ref(code)      ;; code:(Maybe ^Cell) = Just ^Cell (1 + ref)
        .store_maybe_ref(data)      ;; data:(Maybe ^Cell) = Just ^Cell (1 + ref)
        .store_uint(0, 1)           ;; library:(HashmapE 256 SimpleLib) = empty (0)
        .end_cell();
}

;; Вычисление адреса контракта по StateInit
slice calculate_address_by_state_init(cell state_init) inline {
    return begin_cell()
        .store_uint(4, 3)  ;; addr_std$10 anycast:(Maybe Anycast) workchain_id:int8
        .store_int(0, 8)   ;; workchain = 0
        .store_uint(cell_hash(state_init), 256)
        .end_cell()
        .begin_parse();
}

;; Отправка deploy сообщения
() send_deploy_message(slice addr, cell state_init, int amount) impure inline {
    send_raw_message(
        begin_cell()
            .store_uint(msg_flag::bounceable, 6)  ;; flags
            .store_slice(addr)                     ;; destination
            .store_coins(amount)                   ;; amount
            .store_uint(0, 1 + 4 + 4 + 64 + 32)   ;; ihr_disabled=0, fees=0, timestamps=0
            .store_uint(1, 1)                      ;; init=1 (StateInit present)
            .store_uint(0, 1)                      ;; body=0 (body inline, пустое)
            .store_ref(state_init)                 ;; StateInit cell
            .end_cell(),
        mode::pay_fees_separately  ;; Комиссия вычитается из баланса Factory, не из amount
    );
}

;; Отправка TON
() send_ton(slice to, int amount, int mode) impure inline {
    send_raw_message(
        begin_cell()
            .store_uint(msg_flag::bounceable, 6)
            .store_slice(to)
            .store_coins(amount)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .end_cell(),
        mode
    );
}

;; =============== Get Methods ===============

slice get_owner() method_id {
    (slice owner, _, _) = load_data();
    return owner;
}

int get_total_deployed() method_id {
    (_, _, int total_deployed) = load_data();
    return total_deployed;
}

(slice, int) get_factory_info() method_id {
    (slice owner, _, int total_deployed) = load_data();
    return (owner, total_deployed);
}
