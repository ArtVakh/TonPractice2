#include "imports/stdlib.fc";

;; Registry Contract - реестр всех Escrow сделок
;;
;; Storage:
;;   owner: MsgAddress - владелец реестра
;;   total_deals: uint64 - всего зарегистрировано сделок
;;   active_deals: uint64 - активных сделок
;;   completed_deals: uint64 - завершенных сделок
;;   disputed_deals: uint64 - сделок в споре
;;   refunded_deals: uint64 - возвращенных сделок

;; Операции (op codes)
const int op::register_deal = 1;     ;; Регистрация новой сделки
const int op::update_status = 2;     ;; Обновление статуса сделки
const int op::change_owner = 3;      ;; Смена владельца

;; Статусы (должны совпадать с Escrow)
const int status::active = 0;
const int status::completed = 1;
const int status::disputed = 2;
const int status::refunded = 3;

;; Errors
const int error::invalid_op = 100;
const int error::unauthorized = 101;
const int error::invalid_status = 102;

;; =============== Messages ===============

() recv_internal(cell in_msg_full, slice in_msg_body) impure {
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    
    if (flags & 1) {
        return ();
    }

    slice sender_address = cs~load_msg_addr();
    
    ;; Пустое сообщение → bounce
    throw_if(error::invalid_op, in_msg_body.slice_empty?());
    
    int op = in_msg_body~load_uint(32);
    
    ;; Валидация op code
    throw_unless(error::invalid_op, (op >= 1) & (op <= 3));
    
    (slice owner, int total, int active, int completed, int disputed, int refunded) = load_data();

    ;; === Регистрация новой сделки ===
    if (op == op::register_deal) {
        ;; Любой Escrow контракт может зарегистрировать сделку
        ;; В production можно добавить whitelist контрактов
        
        save_data(owner, total + 1, active + 1, completed, disputed, refunded);
        return ();
    }

    ;; === Обновление статуса сделки ===
    if (op == op::update_status) {
        ;; Читаем старый и новый статус
        int old_status = in_msg_body~load_uint(8);
        int new_status = in_msg_body~load_uint(8);
        
        ;; Валидация статусов
        throw_unless(error::invalid_status, 
            (old_status >= 0) & (old_status <= 3) & 
            (new_status >= 0) & (new_status <= 3)
        );
        
        ;; Уменьшаем счетчик старого статуса
        if (old_status == status::active) {
            active -= 1;
        }
        if (old_status == status::completed) {
            completed -= 1;
        }
        if (old_status == status::disputed) {
            disputed -= 1;
        }
        if (old_status == status::refunded) {
            refunded -= 1;
        }
        
        ;; Увеличиваем счетчик нового статуса
        if (new_status == status::active) {
            active += 1;
        }
        if (new_status == status::completed) {
            completed += 1;
        }
        if (new_status == status::disputed) {
            disputed += 1;
        }
        if (new_status == status::refunded) {
            refunded += 1;
        }
        
        save_data(owner, total, active, completed, disputed, refunded);
        return ();
    }

    ;; === Смена владельца ===
    if (op == op::change_owner) {
        throw_unless(error::unauthorized, equal_slices(sender_address, owner));
        
        slice new_owner = in_msg_body~load_msg_addr();
        save_data(new_owner, total, active, completed, disputed, refunded);
        return ();
    }

    throw(error::invalid_op);
}

;; =============== Storage ===============

(slice, int, int, int, int, int) load_data() inline {
    slice ds = get_data().begin_parse();
    
    return (
        ds~load_msg_addr(),    ;; owner
        ds~load_uint(64),      ;; total_deals
        ds~load_uint(64),      ;; active_deals
        ds~load_uint(64),      ;; completed_deals
        ds~load_uint(64),      ;; disputed_deals
        ds~load_uint(64)       ;; refunded_deals
    );
}

() save_data(slice owner, int total, int active, int completed, int disputed, int refunded) impure inline {
    set_data(
        begin_cell()
            .store_slice(owner)
            .store_uint(total, 64)
            .store_uint(active, 64)
            .store_uint(completed, 64)
            .store_uint(disputed, 64)
            .store_uint(refunded, 64)
            .end_cell()
    );
}

;; =============== Helpers ===============

int equal_slices(slice a, slice b) inline {
    return equal_slice_bits(a, b);
}

;; =============== Get Methods ===============

slice get_owner() method_id {
    (slice owner, _, _, _, _, _) = load_data();
    return owner;
}

int get_total_deals() method_id {
    (_, int total, _, _, _, _) = load_data();
    return total;
}

int get_active_deals() method_id {
    (_, _, int active, _, _, _) = load_data();
    return active;
}

int get_completed_deals() method_id {
    (_, _, _, int completed, _, _) = load_data();
    return completed;
}

int get_disputed_deals() method_id {
    (_, _, _, _, int disputed, _) = load_data();
    return disputed;
}

int get_refunded_deals() method_id {
    (_, _, _, _, _, int refunded) = load_data();
    return refunded;
}

;; Получить всю статистику
(int, int, int, int, int) get_stats() method_id {
    (_, int total, int active, int completed, int disputed, int refunded) = load_data();
    return (total, active, completed, disputed, refunded);
}
